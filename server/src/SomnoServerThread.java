import java.util.HashSet;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.*;
import java.time.format.DateTimeFormatter;
import java.time.LocalDateTime;


/**
 * Defines a SomnoServerThread, which is started by the SomnoServer
 */
public class SomnoServerThread extends Thread {
    HashSet<SomnoServerThread> connectedUsers;
    private Socket socket;
    private BufferedReader receive;
    private PrintWriter send;
    private String nickname;
    private boolean kicked = false;
    private String pwd;

    /**
     * Constructor for a SomnoServerThread. Stores the socket and connectedusers
     * @param socket the socket it's connecting on
     * @param connectedUsers the HashSet of connected users
     */
    public SomnoServerThread(Socket socket, HashSet<SomnoServerThread> connectedUsers, String pwd) {
        this.socket = socket;
        this.connectedUsers = connectedUsers;
        this.pwd = pwd;
    }

    /**
     * Logs a message to the console
     * @param msg the message
     */
    public synchronized void log(String msg) {
        System.out.println(msg);
    }

    /**
     * Loop through all the other connections and make them send out the received message.
     * The opcode specifies how the message should be formatted
     *
     * Key:
     *      0: standard message (nickname, time, msg)
     *      1: new connection message (msg, "connected at ", time)
     *      2: disconnect message (msg, " disconnected at ", time)
     *
     * @param msg the message to send out
     * @param opcode the opcode to use to format the message
     */
    public synchronized void update(String msg, int opcode) {
        String time = getDateTimeAsString();
        switch (opcode) { //format the message based on the opcode
            case 0:
                msg = nickname + " [" + time + "] > " + msg;
                break;
            case 1:
                msg = msg + " connected at [" + time + "]";
                break;
            case 2:
                msg = msg + " disconnected at [" + time + "]";
                break;
        }

        //execute on each connection
        for (SomnoServerThread thread : connectedUsers) {
            //print the message on each thread's outstream
            thread.sendMessage(msg);
        }

        log(msg);

    }

    /**
     * Sends a message to the client
     * @param msg the preformatted message
     */
    public void sendMessage(String msg) {
        if (send != null) {
            send.println(msg);
        }
    }

    public void kick() throws IOException {
        kicked = true;
        closeConnections(this.receive, this.send);

    }

    /**
     * Closes the connections and shuts down the thread
     * @param receive the receiver, a BufferedReader
     * @param send the sender, a PrintWriter
     * @throws IOException thrown when receive, send, or socket are already closed
     */
    private void closeConnections(BufferedReader receive, PrintWriter send) throws IOException {
        send.println("/logout");
        receive.close();
        send.close();
        socket.close();
    }

    public String getNickname() {
        return nickname;
    }

    /**
     * Takes in a nickname generated by the user and checks if it's been taken
     * If it has been, checks numerical permutations of that nickname (eg nickname1, nickname2, ect) and assigns
     * that value as the nickname
     *
     * @param nick
     * @param count
     * @return
     */
    public String getValidNickname(String nick, int count) {
        String newNick = nick;
        while (true) {
            if (checkNickname(newNick)) {
                newNick = nick.concat(String.valueOf(count));
                count++;
            } else {
                break; //bad code, need to fix later. Maybe use recursion
            }
        }
        return newNick;
    }

    /**
     * Checks if a nickname is taken. Returns true if it's taken, false if not
     * @param nick the string provided by the user as the requested nickname
     * @return true if nick is available, false if not
     */
    public boolean checkNickname(String nick) {
        for (SomnoServerThread thread : connectedUsers) {
            if (!(thread.equals(this))) {
                if (thread.getNickname().equals(nick)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Gets a string that represents the current date and time
     * @return The date and time, represented as year/moth/day hour:minute:second
     */
    public String getDateTimeAsString() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        LocalDateTime now = LocalDateTime.now();
        return dtf.format(now);
    }

    public void run() {

        try {
            send = new PrintWriter(socket.getOutputStream(), true);
            receive = new BufferedReader(
                    new InputStreamReader(socket.getInputStream()));

            //if the server requires a password, read that in as the first line from the user
            //compare that to the server password. If they match, continue as normal. If not, send
            //an error to the user and close the connection.
            //requires the "/pwd password" protocol format and "/nick nickname" to work properly
            if (!pwd.equals("")) {
                //read the password from the user
                String pwd_cmd = receive.readLine();
                String[] split_cmd = pwd_cmd.split(" ");

                //check if the password has the proper format
                if (!(split_cmd[0].equals("/pwd") && split_cmd.length > 1)) {
                    //if the format is bad, print an error and close the connection
                    send.println("Error: password not given");
                    send.println("/logout");
                }

                if(!(split_cmd[1].equals(pwd))) {
                    send.println("Error: password was incorrect");
                    send.println("/logout");
                }

            }

            nickname = getValidNickname(receive.readLine(), 1); //gets the nickname
            update(nickname, 1);

            String msgIn;
            while (!kicked) {
                msgIn = receive.readLine();
                if (msgIn != null) {
                    if (msgIn.equals("/logout")) {
                        break;
                    } else { //send message to all connected clients
                        update(msgIn, 0);
                    }
                }


            }
        } catch (IOException e) {
            System.out.println("IOException caught. Client may have closed unexpectedly");
            //call signoff message stuff
            update(nickname, 2);
        }
        catch (NullPointerException e) {
            e.printStackTrace();
        } finally {
            try {
                update(nickname, 2);
                closeConnections(receive, send);
                connectedUsers.remove(this);
            } catch (IOException e) {
                System.out.println("Error closing socket");
                e.printStackTrace();
            }
        }
    }
}
